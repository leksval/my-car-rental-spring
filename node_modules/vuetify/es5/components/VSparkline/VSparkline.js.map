{"version":3,"sources":["../../../src/components/VSparkline/VSparkline.ts"],"names":[],"mappings":"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","sourcesContent":["// Mixins\nimport Colorable from '../../mixins/colorable'\n\n// Utilities\nimport mixins, { ExtractVue } from '../../util/mixins'\nimport { genPoints } from './helpers/core'\nimport { genPath } from './helpers/path'\n\n// Types\nimport Vue, { VNode } from 'vue'\nimport { Prop } from 'vue/types/options'\n\nexport type SparklineItem = number | { value: number }\n\nexport type SparklineText = {\n  x: number\n  value: string\n}\n\nexport interface Boundary {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n}\n\nexport interface Point {\n  x: number\n  y: number\n  value: number\n}\n\ninterface options extends Vue {\n  $refs: {\n    path: SVGPathElement\n  }\n}\n\nexport default mixins<options &\n/* eslint-disable indent */\n  ExtractVue<[\n    typeof Colorable\n  ]>\n/* eslint-enable indent */\n>(\n  Colorable\n).extend({\n  name: 'VSparkline',\n\n  props: {\n    autoDraw: Boolean,\n    autoDrawDuration: {\n      type: Number,\n      default: 2000\n    },\n    autoDrawEasing: {\n      type: String,\n      default: 'ease'\n    },\n    color: {\n      type: String,\n      default: 'primary'\n    },\n    gradient: {\n      type: Array as Prop<string[]>,\n      default: () => ([])\n    },\n    gradientDirection: {\n      type: String as Prop<'top' | 'bottom' | 'left' | 'right'>,\n      validator: (val: string) => ['top', 'bottom', 'left', 'right'].includes(val),\n      default: 'top'\n    },\n    height: {\n      type: [String, Number],\n      default: 75\n    },\n    labels: {\n      type: Array as Prop<SparklineItem[]>,\n      default: () => ([])\n    },\n    lineWidth: {\n      type: [String, Number],\n      default: 4\n    },\n    padding: {\n      type: [String, Number],\n      default: 8\n    },\n    smooth: {\n      type: [Boolean, Number, String],\n      default: false\n    },\n    showLabels: Boolean,\n    value: {\n      type: Array as Prop<SparklineItem[]>,\n      default: () => ([])\n    },\n    width: {\n      type: [Number, String],\n      default: 300\n    }\n  },\n\n  data: () => ({\n    lastLength: 0\n  }),\n\n  computed: {\n    boundary (): Boundary {\n      const padding = Number(this.padding)\n      const height = Number(this.height)\n      const width = Number(this.width)\n\n      return {\n        minX: padding,\n        minY: padding,\n        maxX: width - padding,\n        maxY: height - padding\n      }\n    },\n    hasLabels (): boolean {\n      return Boolean(\n        this.showLabels ||\n        this.labels.length > 0 ||\n        this.$scopedSlots.label\n      )\n    },\n    parsedLabels (): SparklineText[] {\n      const labels = []\n      const points = this.points\n      const len = points.length\n\n      for (let i = 0; labels.length < len; i++) {\n        const item = points[i]\n        let value = this.labels[i]\n\n        if (!value) {\n          value = item === Object(item)\n            ? item.value\n            : item\n        }\n\n        labels.push({\n          ...item,\n          value: String(value)\n        })\n      }\n\n      return labels\n    },\n    points (): Point[] {\n      return genPoints(this.value.slice(), this.boundary)\n    },\n    textY (): number {\n      return this.boundary.maxY + 6\n    }\n  },\n\n  watch: {\n    value: {\n      immediate: true,\n      handler () {\n        this.$nextTick(() => {\n          if (!this.autoDraw) return\n\n          const path = this.$refs.path\n          const length = path.getTotalLength()\n\n          path.style.transition = 'none'\n          path.style.strokeDasharray = length + ' ' + length\n          path.style.strokeDashoffset = Math.abs(length - (this.lastLength || 0)).toString()\n          path.getBoundingClientRect()\n          path.style.transition = `stroke-dashoffset ${this.autoDrawDuration}ms ${this.autoDrawEasing}`\n          path.style.strokeDashoffset = '0'\n          this.lastLength = length\n        })\n      }\n    }\n  },\n\n  methods: {\n    genGradient () {\n      const gradientDirection = this.gradientDirection\n      const gradient = this.gradient.slice()\n\n      // Pushes empty string to force\n      // a fallback to currentColor\n      if (!gradient.length) gradient.push('')\n\n      const len = Math.max(gradient.length - 1, 1)\n      const stops = gradient.reverse().map((color, index) =>\n        this.$createElement('stop', {\n          attrs: {\n            offset: index / len,\n            'stop-color': color || 'currentColor'\n          }\n        })\n      )\n\n      return this.$createElement('defs', [\n        this.$createElement('linearGradient', {\n          attrs: {\n            id: this._uid,\n            x1: +(gradientDirection === 'left'),\n            y1: +(gradientDirection === 'top'),\n            x2: +(gradientDirection === 'right'),\n            y2: +(gradientDirection === 'bottom')\n          }\n        }, stops)\n      ])\n    },\n    genLabels () {\n      if (!this.hasLabels) return undefined\n\n      return this.$createElement('g', {\n        style: {\n          fontSize: '8',\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: 'currentColor'\n        }\n      }, this.parsedLabels.map(this.genText))\n    },\n    genPath () {\n      const radius = this.smooth === true ? 8 : Number(this.smooth)\n\n      return this.$createElement('path', {\n        attrs: {\n          id: this._uid,\n          d: genPath(this.points.slice(), radius),\n          fill: 'none',\n          stroke: `url(#${this._uid})`\n        },\n        ref: 'path'\n      })\n    },\n    genText (item: SparklineText, index: number) {\n      const children = this.$scopedSlots.label\n        ? this.$scopedSlots.label({ index, value: item.value })\n        : item.value\n\n      return this.$createElement('text', {\n        attrs: {\n          x: item.x,\n          y: this.textY\n        }\n      }, [children])\n    }\n  },\n\n  render (h): VNode {\n    if (this.value.length < 2) return undefined as never\n\n    return h('svg', this.setTextColor(this.color, {\n      attrs: {\n        'stroke-width': this.lineWidth || 1,\n        width: '100%',\n        height: '25%',\n        viewBox: `0 0 ${this.width} ${this.height}`\n      }\n    }), [\n      this.genGradient(),\n      this.genLabels(),\n      this.genPath()\n    ])\n  }\n})\n"],"sourceRoot":""}